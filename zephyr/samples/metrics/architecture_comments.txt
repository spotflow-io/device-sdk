
  Issue 3: Sequence Number Increment Not Thread-Safe (BUG)

  Location: spotflow_metrics_cbor.c:96
  succ = succ && zcbor_uint64_put(state, metric->sequence_number++);

  Problem: sequence_number++ is not atomic. The mutex is on the aggregator, but CBOR encoding happens after mutex release in
  some paths.

  Risk: Race condition could cause duplicate sequence numbers in concurrent scenarios.

  Recommendation: Move sequence number increment inside the mutex-protected section in aggregator.

  ---
  Issue 4: Double-Free Risk in enqueue_metric_message (BUG)

  Location: spotflow_metrics_aggregator.c:123-128
  if (rc != 0) {
      /* Queue full - free both message structure and payload */
      k_free(msg);
      k_free(payload);  // payload is already passed to this function
      ...
  }

  Problem: When flush_timeseries calls enqueue_metric_message and it fails, the error path already frees cbor_data at line 164.
   But enqueue_metric_message also frees payload (same pointer) at line 125. This causes double-free.

  Location of double-free: spotflow_metrics_aggregator.c:160-165
  rc = enqueue_metric_message(cbor_data, cbor_len);
  if (rc < 0) {
      /* Enqueue failed - encoder must free immediately */
      k_free(cbor_data);  // DOUBLE FREE - already freed inside enqueue_metric_message
      ...
  }

  Recommendation: Remove k_free(payload) from enqueue_metric_message error path - let caller handle it.

  ---
  Issue 5: System Metrics g_system_metrics_initialized Not Atomic (MINOR BUG)

  Location: spotflow_metrics_system.c:57
  static bool g_system_metrics_initialized = false;

  Problem: Unlike the main metrics init which uses atomic operations, system metrics uses a plain bool. Race condition if
  spotflow_metrics_system_init() called from multiple threads.

  Risk: Low (typically called once from MQTT thread), but inconsistent with main metrics pattern.

  ---
  Issue 6: Missing Duplicate Metric Name Check (BUG)

  Design says: "Duplicate metric name" should return NULL

  Implementation: register_metric_common() doesn't check if a metric with the same name already exists. It just finds any
  available slot.

  Risk: Registering same metric name twice creates two separate metrics, violating uniqueness requirement.

  ---
  Issue 7: Memory Usage Concerns

  The dimension storage uses 256 bytes per key and 256 bytes per value:
  struct metric_dimension_storage {
      char key[256];
      char value[256];
  };

  With CONFIG_SPOTFLOW_METRICS_MAX_DIMENSIONS_PER_METRIC=8, each timeseries slot uses:
  - 8 × (256 + 256) = 4096 bytes just for dimensions

  A metric with max_timeseries=18 would use:
  - 18 × 4096 = 73,728 bytes for dimension storage alone

  Recommendation: Use smaller buffers (32/64 bytes) matching the design spec.

  ---
  Issue 8: CBOR Map Size May Be Wrong

  Location: spotflow_metrics_cbor.c:75
  succ = succ && zcbor_map_start_encode(state, MAX_MAP_ENTRIES);

  MAX_MAP_ENTRIES = 10 but actual entries vary:
  - Base: 5 (messageType, metricName, aggregationInterval, deviceUptimeMs, sequenceNumber, sum)
  - Optional: labels, sumTruncated, count, min, max

  For PT0S metrics without labels, only 6 entries. For aggregated with labels+truncated, up to 10.

  Risk: zcbor may waste space or fail validation with mismatched count.


